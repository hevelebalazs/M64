struct Bitmap
{
	width: Int32;
	height: Int32;
	pixels:@[height, width]UInt32;
}

struct State
{
	offset: Int32;
}

func InitState(state: @State)
{
	state.offset = 0;
}

struct V4
{
	x, y, z, w: Real32;
	#r := x;
	#g := y;
	#b := z;
	#a := w;
}

func Color(r, g, b: Real32): V4
{
	color: V4;
	color.r = r;
	color.g = g;
	color.b = b;
	color.a = 1;
	return color;
}

func ColorToColorCode(color: V4): UInt32
{
	r := UInt32(color.r * 255);
	g := UInt32(color.g * 255);
	b := UInt32(color.b * 255);
	a := UInt32(color.a * 255);

	code := (a << 24) + (r << 16) + (g << 8) + (b << 0);
	return code;
}

func FloatDiv(a, b: Int32): Real32
{
	r := Real32(a) / Real32(b);
	return r;
}

func DrawGradient(bitmap: @Bitmap, state: @State)
{
	use bitmap;
	// for row, col: in pixels
	for row := 0 to < height
	{
		row_ratio := FloatDiv(row, height - 1);
		for col := 0 to < width
		{
			col1 := col + state.offset;
			if col1 >= width
			{
				col1 -= width;
			}
			col_ratio := FloatDiv(col1, width - 1);

			color := Color(row_ratio, col_ratio, 0);
			color_code := ColorToColorCode(color);

			pixels[row, col] = color_code;
		}
	}
}

func Draw(memory: @UInt32, width, height: Int32, state: @State)
{
	bitmap: Bitmap;
	bitmap.width = width;
	bitmap.height = height;
	bitmap.pixels = memory;

	state.offset++;
	if state.offset >= width
	{
		state.offset = 0;
	}

	DrawGradient(@bitmap, state);
}