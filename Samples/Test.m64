struct State
{
	x, y: Int32;
}

func InitState(state: @State)
{
	use state;
	x = 0;
	y = 0;
}

struct V4
{
	x, y, z, w: Real32;
	#r := x;
	#g := y;
	#b := z;
	#a := w;
}

func Color(r, g, b: Real32): V4
{
	color: V4;
	color.r = r;
	color.g = g;
	color.b = b;
	color.a = 1;
	return color;
}

func ColorToColorCode(color: V4): UInt32
{
	r := :UInt32(color.r * 255);
	g := :UInt32(color.g * 255);
	b := :UInt32(color.b * 255);
	a := :UInt32(color.a * 255);

	code := (a << 24) + (r << 16) + (g << 8) + (b << 0);
	return code;
}

func FloatDiv(a, b: Int32): Real32
{
	r := :Real32(a) / :Real32(b);
	return r;
}

// TODO: create a general pointer type that's like void *
struct MemoryWriter
{
	at:@Int8;
}

/*
TODO: make a meta func for writing any value

#func WriteValue(writer: @MemoryWriter, v: #Value)
{
	use writer;
	#type := v.type;
	:@type(at)@ = v;
	at += #TypeSize(type);
}
*/

func WriteInt32(writer: @MemoryWriter, v: Int32)
{
	use writer;
	:@Int32(at)@ = v;
	at += 4;
}

// TODO: use function param
// func WriteUInt32(use writer: @MemoryWriter, v: UInt32)
func WriteUInt32(writer: @MemoryWriter, v: UInt32)
{
	use writer;
	:@UInt32(at)@ = v;
	at += 4;
}

/*
TODO: write a meta func that takes multiple parameters
Write(w, minx, maxx, miny, maxy, color);

#func Write(w: @MemoryWrite, params: #ParamList)
{
	#for p := in params
	{
		WriteValue(w, p.value);
	}
}
*/

func StopRender(w: @MemoryWriter)
{
	WriteInt32(w, 0);
}

func RenderRect(w: @MemoryWriter, minx, maxx, miny, maxy: Int32, color: V4)
{
	color_code := ColorToColorCode(color);

	WriteInt32(w, 1);
	WriteInt32(w, minx);
	WriteInt32(w, maxx);
	WriteInt32(w, miny);
	WriteInt32(w, maxy);
	WriteUInt32(w, color_code);
}

// TODO: follow mouse
func Draw(width, height: Int32, render_memory:@Int8, state: @State, mouse_x, mouse_y: Int32)
{
	w: MemoryWriter;
	w.at = render_memory;

	background_color := Color(0, 0, 0);
	RenderRect(@w, 0, width, 0, height, background_color);

	use state;

	// TODO: make sure type gets inferred properly
	// radius := 25;
	radius := :Int32(25);

	rect_color := Color(0, 0, 1);
	RenderRect(@w, x - radius, x + radius, y - radius, y + radius, rect_color);

	if x < mouse_x { x++; }
	if x > mouse_x { x--; }

	if y < mouse_y { y++; }
	if y > mouse_y { y--; }

	StopRender(@w);
}