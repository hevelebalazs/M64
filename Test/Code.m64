struct Bitmap
{
	memory: @uint;
	width: int;
	height: int;
}

func FillWithColor(bitmap: @Bitmap, color: uint)
{
	pixel := bitmap.memory;
	for row := 0; row < bitmap.height; row++
	{
		for col := 0; col < bitmap.width; col++
		{
			[[pixel]] = color;
			pixel++;
		}
	}
}

func SetPixelColor(bitmap: @Bitmap, row, col: int, color: uint)
{
	bitmap.memory[row * bitmap.width + col] = color;
}

struct float2
{
	x, y: float;
}

struct Quad2
{
	p:[4]float2;
}

func Float2XY(x, y: float) float2
{
	result: float2;
	result.x = x;
	result.y = y;
	return result;
}

operator- F2sub(p1:float2, p2:float2) float2
{
	return Float2XY(p1.x - p2.x, p1.y - p2.y);
}

func TurnsRight(p0, p1, p2: float2) bool
{
	d0 := F2sub(p1, p0);
	d1 := F2sub(p2, p1);
	
	det := (d0.x * d1.y) - (d0.y * d1.x);
	turns_right := (det < 0.0);
	return turns_right;
}

func IsPointInQuad2(p: float2, q: Quad2) bool
{
	is_inside := true;
	is_inside &= TurnsRight(q.p[0], q.p[1], p);
	is_inside &= TurnsRight(q.p[1], q.p[2], p);
	is_inside &= TurnsRight(q.p[2], q.p[3], p);
	is_inside &= TurnsRight(q.p[3], q.p[0], p);
	return is_inside;
}

func DrawQuad2(bitmap: @Bitmap, quad: Quad2, color: uint)
{
	min_x := quad.p[0].x;
	max_x := quad.p[0].x;
	min_y := quad.p[0].y;
	max_y := quad.p[0].y;
	
	for i := 1; i < 4; i++
	{
		x := quad.p[i].x;
		y := quad.p[i].y;
		if x < min_x
		{
			min_x = x;
		}
		if x > max_x
		{
			max_x = x;
		}
		if y < min_y
		{
			min_y = y;
		}
		if y > max_y
		{
			max_y = y;
		}
	}
	
	for row := int::min_y; row < int::max_y + 1; row++
	{
		for col := int::min_x; col < int::max_x + 1; col++
		{
			p := Float2XY(float::col, float::row);
			if IsPointInQuad2(p, quad)
			{
				SetPixelColor(bitmap, row, col, color);
			}
		}
	}
}

func DrawRectMinMax(bitmap: @Bitmap, min_row, min_col, max_row, max_col: int, color: uint)
{
	for row := min_row; row <= max_row; row++
	{
		for col := min_col; col <= max_col; col++
		{
			index := row * bitmap.width + col;
			bitmap.memory[index] = color;
		}
	}
}